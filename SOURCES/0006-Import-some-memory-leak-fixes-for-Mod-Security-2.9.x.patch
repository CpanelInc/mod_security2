From 58ba9bd21ac0616c60a54d2107a0c729fdfef68c Mon Sep 17 00:00:00 2001
From: Gary Stanley <gary@cpanel.net>
Date: Thu, 14 Oct 2021 05:12:39 +0000
Subject: [PATCH] Import some memory leak fixes for Mod Security 2.9.x

- Fix memory leaks caused by unfreed compiled regex data. This was determined
to be more of an issue when Mod Security is compiled with PCRE's JIT, but it still slowly leaks when it's disabled (the default)

https://github.com/SpiderLabs/ModSecurity/pull/2263/commits

- Backport local memory pool enhancement from 3.x pull request

https://github.com/SpiderLabs/ModSecurity/pull/2177

- Memory leak in modsecurity_request_body_to_stream

https://github.com/SpiderLabs/ModSecurity/issues/2208

This might help bigger customers reporting memory/performance problems (godaddy, etc).

Fixup build failures on CentOS6 by reverting part of the patch for C6 only.

C6's PCRE, which is the 7.x series, doesn't have pcre_study etc.

Since C6 is EOL, this isn't a huge deal.
---
 apache2/modsecurity.c | 15 ++++++++++++
 apache2/msc_pcre.c    | 28 +++++++++++++++--------
 apache2/re.c          | 53 ++++++++++++++++---------------------------
 3 files changed, 52 insertions(+), 44 deletions(-)

diff --git a/apache2/modsecurity.c b/apache2/modsecurity.c
index dcdb485..8ab13f7 100644
--- a/apache2/modsecurity.c
+++ b/apache2/modsecurity.c
@@ -322,6 +322,21 @@ static apr_status_t modsecurity_tx_cleanup(void *data) {
     #endif
 #endif
 
+    if (msr->stream_input_data != NULL) {
+        free(msr->stream_input_data);
+        msr->stream_input_data = NULL;
+        msr->stream_input_length = 0;
+/* --enable-large-stream-input */
+#ifdef MSC_LARGE_STREAM_INPUT
+        msr->stream_input_allocated_length = 0;
+#endif
+    }
+    if (msr->stream_output_data != NULL) {
+        free(msr->stream_output_data);
+        msr->stream_output_data = NULL;
+        msr->stream_output_length = 0;
+    }
+
     return APR_SUCCESS;
 }
 
diff --git a/apache2/msc_pcre.c b/apache2/msc_pcre.c
index 8534a20..7460215 100644
--- a/apache2/msc_pcre.c
+++ b/apache2/msc_pcre.c
@@ -21,11 +21,11 @@
 static apr_status_t msc_pcre_cleanup(msc_regex_t *regex) {
     if (regex != NULL) {
         if (regex->pe != NULL) {
-#if defined(VERSION_NGINX)
-            pcre_free(regex->pe);
-#else
+#if PCRE_MAJOR >= 8
+            pcre_free_study(regex->pe);
+#else 
             free(regex->pe);
-#endif
+#endif 
             regex->pe = NULL;
         }
         if (regex->re != NULL) {
@@ -65,21 +65,29 @@ void *msc_pregcomp_ex(apr_pool_t *pool, const char *pattern, int options,
     }
     if (regex->re == NULL) return NULL;
 
-    #ifdef WITH_PCRE_STUDY
+/* PCRE on CentOS 6 doesn't have PCRE_STUDY_NEEDED, omit for now */ 
+#if PCRE_MAJOR >= 8 
+    #ifdef WITH_PCRE_STUDY /* This is enabled by default on modsec 2.9.3+ */ 
+        #ifdef WITH_PCRE_JIT /* Disabled by default on cPanel builds */ 
+		pe = pcre_study(regex->re, PCRE_STUDY_EXTRA_NEEDED|PCRE_STUDY_JIT_COMPILE, &errptr);
+        #else
+		pe = pcre_study(regex->re, PCRE_STUDY_EXTRA_NEEDED, &errptr);
+        #endif
+    #endif
+
+#else /* Fallback for CentOS 6/CL6 PCRE's version */ 
+  #ifdef WITH_PCRE_STUDY
         #ifdef WITH_PCRE_JIT
                 pe = pcre_study(regex->re, PCRE_STUDY_JIT_COMPILE, &errptr);
         #else
                 pe = pcre_study(regex->re, 0, &errptr);
         #endif
     #endif
+#endif
 
     /* Setup the pcre_extra record if pcre_study did not already do it */
     if (pe == NULL) {
-#if defined(VERSION_NGINX)
-        pe = pcre_malloc(sizeof(pcre_extra));
-#else
-        pe = malloc(sizeof(pcre_extra));
-#endif
+	pe = pcre_malloc(sizeof(pcre_extra));
         if (pe == NULL) {
             return NULL;
         }
diff --git a/apache2/re.c b/apache2/re.c
index 64a2a6a..c7c3387 100644
--- a/apache2/re.c
+++ b/apache2/re.c
@@ -245,18 +245,24 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
     char *opt = NULL, *param = NULL;
     char *target_list = NULL, *replace = NULL;
     int i, rc, match = 0, var_appended = 0;
+    apr_pool_t *local_pool = NULL;
 
     if(rule != NULL)    {
+        apr_status_t status = apr_pool_create(&local_pool, NULL);
+        if (status < 0) {
+            return apr_psprintf(ruleset->mp, "Error creating memory pool: %d", status);
+        }
 
-        target_list = strdup(p2);
-        if(target_list == NULL)
+        target_list = apr_pstrdup(local_pool, p2);
+        if(target_list == NULL) {
+            apr_pool_destroy(local_pool);
             return apr_psprintf(ruleset->mp, "Error to update target - memory allocation");;
+        }
 
         if(p3 != NULL)  {
-            replace = strdup(p3);
+            replace = apr_pstrdup(local_pool, p3);
             if(replace == NULL) {
-                free(target_list);
-                target_list = NULL;
+                apr_pool_destroy(local_pool);
                 return apr_psprintf(ruleset->mp, "Error to update target - memory allocation");;
             }
         }
@@ -288,10 +294,7 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
             }
 
             if(apr_table_get(ruleset->engine->variables, name) == NULL)   {
-                if(target_list != NULL)
-                    free(target_list);
-                if(replace != NULL)
-                    free(replace);
+                apr_pool_destroy(local_pool);
                 if(msr) {
                     msr_log(msr, 9, "Error to update target - [%s] is not valid target", name);
                 }
@@ -380,10 +383,11 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
                     goto end;
                 }
             } else {
-
-                target = strdup(p);
-                if(target == NULL)
+                target = apr_pstrdup(local_pool, p);
+                if(target == NULL) {
+                    apr_pool_destroy(local_pool);
                     return NULL;
+                }
 
                 is_negated = is_counting = 0;
                 param = name = value = NULL;
@@ -413,10 +417,7 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
                 }
 
                 if(apr_table_get(ruleset->engine->variables, name) == NULL)   {
-                    if(target_list != NULL)
-                        free(target_list);
-                    if(replace != NULL)
-                        free(replace);
+                    apr_pool_destroy(local_pool);
                     if(msr) {
                         msr_log(msr, 9, "Error to update target - [%s] is not valid target", name);
                     }
@@ -458,11 +459,6 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
                     }
                 }
 
-                if(target != NULL)  {
-                    free(target);
-                    target = NULL;
-                }
-
                 if(match == 0 ) {
                     rc = msre_parse_targets(ruleset, p, rule->targets, &my_error_msg);
                     if (rc < 0) {
@@ -493,7 +489,7 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
         }
 
         if(var_appended == 1)  {
-            current_targets = msre_generate_target_string(ruleset->mp, rule);
+            current_targets = msre_generate_target_string(local_pool, rule);
             rule->unparsed = msre_rule_generate_unparsed(ruleset->mp, rule, current_targets, NULL, NULL);
             rule->p1 = apr_pstrdup(ruleset->mp, current_targets);
             if(msr) {
@@ -508,18 +504,7 @@ char *update_rule_target_ex(modsec_rec *msr, msre_ruleset *ruleset, msre_rule *r
     }
 
 end:
-    if(target_list != NULL) {
-        free(target_list);
-        target_list = NULL;
-    }
-    if(replace != NULL) {
-        free(replace);
-        replace = NULL;
-    }
-    if(target != NULL)  {
-        free(target);
-        target = NULL;
-    }
+    apr_pool_destroy(local_pool);
     return NULL;
 }
 
-- 
2.34.1

